"""Business Intelligence service for Text-to-SQL capabilities."""
import logging
import re
from typing import Dict, Any, List, Optional
from urllib.parse import urlparse, urlunparse

import httpx
from sqlalchemy import create_engine, text
from sqlalchemy.engine import Engine

from app.config import get_settings

logger = logging.getLogger(__name__)
settings = get_settings()

class BIService:
    """Service for handling quantitative queries via SQL."""
    
    def __init__(self):
        self._engine: Optional[Engine] = None
        
    @property
    def engine(self) -> Engine:
        """Lazy load BI engine with restricted permissions."""
        if not self._engine:
            self._engine = self._create_bi_engine()
        return self._engine
    
    def _create_bi_engine(self) -> Engine:
        """Create a SQLAlchemy engine using the read-only BI user."""
        # Parse main DB URL
        parsed = urlparse(settings.database_url)
        
        # Replace username and password with BI user credentials
        # Note: In production, these should be in settings/env vars
        # bi_readonly_password matches the migration script
        new_netloc = f"bi_user:bi_readonly_password@{parsed.hostname}:{parsed.port}"
        
        # Reconstruct URL
        bi_db_url = urlunparse((
            parsed.scheme,
            new_netloc,
            parsed.path,
            parsed.params,
            parsed.query,
            parsed.fragment
        ))
        
        return create_engine(bi_db_url, pool_pre_ping=True)

    def _generate_sql(self, question: str) -> str:
        """Use LLM to generate SQL query from natural language."""
        
        schema_desc = """
Table: v_reporting_documents
Columns:
- document_id (uuid): Unique ID
- filename (text): Name of the file
- status (text): 'extracted', 'validated', etc.
- document_type (text): 'fattura', 'ddt', 'po', 'preventivo'
- upload_date (timestamp): Date file was uploaded
- document_date (timestamp): Date ON the document
- document_number (text): Invoice/Order number
- supplier_name (text): Vendor/Sender
- issuer_name (text): Company issuing the doc
- total_amount (float): Total formatted as number
- net_amount (float): Net amount
- tax_amount (float): VAT amount
- currency (text): ISO currency code (default EUR)
- doc_year (float): Year extracted from document_date
- doc_month (float): Month extracted from document_date

DB Dialect: PostgreSQL
"""
        
        prompt = f"""You are a PostgreSQL expert. Generate a SQL query to answer the user's question.

SCHEMA:
{schema_desc}

RULES:
1. Return ONLY the raw SQL query. No markdown formatting, no explanations.
2. Use ONLY the table `v_reporting_documents`.
3. Use `ILIKE` for case-insensitive text matching.
4. For amounts, use `SUM(total_amount)`, `AVG(...)` etc.
5. If referring to dates, use `doc_year` and `doc_month` when convenient, or standard PostgreSQL date functions on `document_date`.
6. LIMIT results to 10 unless specifically asked otherwise.
7. CAST columns if necessary, but the view handles most types.
8. Do NOT output markdown code blocks (```sql). Just the SQL text.

QUESTION: {question}

SQL:"""

        try:
            with httpx.Client(timeout=30) as client:
                response = client.post(
                    f"{settings.ollama_base_url}/api/generate",
                    json={
                        "model": settings.ollama_chat_model,
                        "prompt": prompt,
                        "stream": False,
                        "options": {"temperature": 0.0}  # Deterministic
                    }
                )
                
                if response.status_code == 200:
                    sql = response.json().get("response", "").strip()
                    # Clean markdown if present
                    sql = re.sub(r'```sql\s*', '', sql, flags=re.IGNORECASE)
                    sql = re.sub(r'```', '', sql).strip()
                    return sql
                else:
                    logger.error(f"LLM SQL Generation failed: {response.status_code}")
                    return ""
        except Exception as e:
            logger.error(f"Error generating SQL: {e}")
            return ""

    def _execute_query(self, sql: str) -> List[Dict[str, Any]]:
        """Execute SQL query safely using BI user."""
        if not sql:
            return []
            
        # Basic extra safety check
        if not sql.lower().startswith("select"):
            logger.warning("Blocked non-SELECT query generated by LLM")
            return []
            
        try:
            with self.engine.connect() as conn:
                result = conn.execute(text(sql))
                # Convert to list of dicts
                keys = result.keys()
                return [dict(zip(keys, row)) for row in result.fetchall()]
        except Exception as e:
            logger.error(f"SQL Execution Error: {e}\nQuery: {sql}")
            return []

    def _synthesize_answer(self, question: str, sql: str, data: List[Dict[str, Any]]) -> str:
        """Explain the data results in natural language."""
        
        if not data:
            return "Ho analizzato i dati ma non ho trovato risultati per la tua richiesta."
            
        context = f"QUERY: {sql}\n\nDATA FOUND ({len(data)} rows):\n{data}"
        
        prompt = f"""You are a business analyst. Explain the data results to the user in Italian.

QUESTION: {question}

{context}

RULES:
1. Answer the question directly using the data.
2. If it's a list, summarize or list the top items.
3. If it's a single number (count/sum), stated it clearly.
4. Mention any currency or units if present.
5. Keep it concise.
6. Speak Italian.

ANSWER:"""

        try:
            with httpx.Client(timeout=30) as client:
                response = client.post(
                    f"{settings.ollama_base_url}/api/generate",
                    json={
                        "model": settings.ollama_chat_model,
                        "prompt": prompt,
                        "stream": False,
                        "options": {"temperature": 0.2} 
                    }
                )
                
                if response.status_code == 200:
                    return response.json().get("response", "").strip()
                return "Ecco i dati trovati (visualizzazione grezza): " + str(data)
        except Exception as e:
            logger.error(f"Error synthesizing answer: {e}")
            return "Ecco i dati trovati: " + str(data)

    def process_query(self, question: str) -> Dict[str, Any]:
        """Main entry point: Generate SQL -> Execute -> Explain."""
        
        # 1. Generate SQL
        sql = self._generate_sql(question)
        if not sql:
            return {"answer": "Non sono riuscito a generare una query per analizzare i dati.", "sql": None, "data": []}
            
        logger.info(f"Generated SQL: {sql}")
        
        # 2. Execute
        data = self._execute_query(sql)
        
        # 3. Explain
        answer = self._synthesize_answer(question, sql, data)
        
        return {
            "answer": answer,
            "sql": sql,
            "data": data
        }

# Global instance
bi_service = BIService()
